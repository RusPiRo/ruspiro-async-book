<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Demystifying Async/Await in Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="./css/styles.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="cover.html">Demystifying Async/Await in Rust</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="01-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-01-motivation.html"><strong aria-hidden="true">1.1.</strong> Motivation</a></li></ol></li><li class="chapter-item expanded "><a href="02-00-terminology.html"><strong aria-hidden="true">2.</strong> Terminology</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02-01-future.html"><strong aria-hidden="true">2.1.</strong> Future</a></li><li class="chapter-item expanded "><a href="02-02-executor.html"><strong aria-hidden="true">2.2.</strong> Executor</a></li><li class="chapter-item expanded "><a href="02-03-async.html"><strong aria-hidden="true">2.3.</strong> Async</a></li><li class="chapter-item expanded "><a href="02-04-await.html"><strong aria-hidden="true">2.4.</strong> Await</a></li></ol></li><li class="chapter-item expanded "><a href="03-00-build-the-runtime.html"><strong aria-hidden="true">3.</strong> Let's Build a Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-01-the-thought.html"><strong aria-hidden="true">3.1.</strong> The Thought</a></li><li class="chapter-item expanded "><a href="03-02-first-brain.html"><strong aria-hidden="true">3.2.</strong> The First Naive Brain</a></li><li class="chapter-item expanded "><a href="03-03-context-and-waker.html"><strong aria-hidden="true">3.3.</strong> The Context and the Waker</a></li><li class="chapter-item expanded "><a href="03-04-mpmc-channel.html"><strong aria-hidden="true">3.4.</strong> MPMC - Channel</a></li><li class="chapter-item expanded "><a href="03-05-simple-brain.html"><strong aria-hidden="true">3.5.</strong> The simple Brain</a></li></ol></li><li class="chapter-item expanded "><a href="04-00-proof-runtime.html"><strong aria-hidden="true">4.</strong> Proof the Runtime</a></li><li class="chapter-item expanded "><a href="05-00-conclusion.html"><strong aria-hidden="true">5.</strong> Conclusion</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="author.html">The Author</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Demystifying Async/Await in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#demystifying-asyncawait-in-rust" id="demystifying-asyncawait-in-rust">Demystifying Async/Await in Rust</a></h1>
<p>This book will explain the backgrounds and implementation details to be able to understand how the async/await programming pattern works in Rust.</p>
<p>The contents shared in this book are based on the experience of the author while implementing the <code>async</code>/<code>await</code> programming style and execution model using the actual version of Rust the Programming Language on a bare metal embedded system.</p>
<p>I hope the following chapters will give everyone who is curious about the things that happens behind the scenes of <code>async</code>/<code>await</code> some insights into this complex and sometimes mystical appearing topic.</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>One of the main promises of asynchronous, parallel processing is that it can increase overal performance of your program. Although this does not apply to any generic situation, most of us would like to try out whether this could give the desired boost to your specific challenge. However, designing and writing a program ready to benefit from asynchronous execution is often challenging and sometimes requires knowledge of how the underlying bits and pieces fit together.</p>
<blockquote>
<p><img src="./images/tip.png" alt="Hint" /> The book assumes that the reader is already familiar with the Rust programming language and it's main concepts and syntax.</p>
</blockquote>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>I'm - at the time of writing - working on a Raspberry Pi OS written as much as possible in Rust. Especially in the space of micro computer and embedded systems where GPIO's are used to access sensors and the like the OS or program often <em>idles</em> waiting for external events but also blocking any further processing while doing so. So the decision was made, that one of the main features of this OS will be, that it utilises the 4 cores of the provided processor of the Raspberry Pi as best as possbile and thus allows asynchronous and parallel processing (without writing a full threading stack). But writing a custom operating system does mean that one need to deal with some restrictions. One with the most impact on the usage of Rust as programming language is, that it is not possible to use the standard library. So everything need to be built with <code>#[no_std]</code> in mind.</p>
<p>While Rusts feature to support asynchronous processing is already available for a while as part of the standard library, it just recently got available in <code>no_std</code> environments thanks to the continues efforts of the Rust language group. Even though the whole <em>async/await</em> in Rust was quite a mystery to me I started to design and implement a runtime for my Raspberry Pi OS. This pretty much allowd me to understand all the different pieces - like <code>async fn()</code> and <code>future.await</code> thingies - that build the entire asynchronous features available for the developer with a concise syntax and also enabled me to know how everything fits together.</p>
<p>To share my experience and insights that lead to the <em>de-mystification</em> for me I've written this book to also help others to have this kind of <em>a-ha</em> 💡 effect.</p>
<h1><a class="header" href="#terminology" id="terminology">Terminology</a></h1>
<p>Before we start implementing our own runtime as part of the custom operating system with the help of the following chapters, let's cover some terms to ensure a common understanding througout this book.</p>
<h2><a class="header" href="#future" id="future">Future</a></h2>
<p>A <code>Future</code> represents the processing whose result may be available at a <em>future</em> point in time. The actual procesing result need to be actively requested. This is called <em>polling</em> and is implemented as the <code>poll</code> function on the <code>Future</code> trait. The result of the <code>poll</code> function represents the the state of the <code>Future</code>. It could either be <code>Ready</code> yielding the actual result of the processing, or <code>Pending</code> indicating that the actual result is still not available.</p>
<h2><a class="header" href="#executor" id="executor">Executor</a></h2>
<p>The <em>Executor</em> is the working horse of the asynchronous processing. He pretty much represents the runtime that is able to continuesely request the result of every <code>Future</code> until they return the <code>Ready</code> state. Registering a <code>Future</code> at the <em>Executor</em> to allow the same to run it to completion is called <em>spawning</em>. As part of this the <code>Future</code> is wrapped into a structure that allows proper handling of processing and re-spawning of pending futures. In the Rust libraries this wrapper is typically called a <em>Task</em>.</p>
<h1><a class="header" href="#async" id="async">Async</a></h1>
<p>The term <code>async</code> is a keyword in the Rust programming language. It is used to tell the compiler that a function is able to be processed asynchronously. This keyword can be seen as syntactic sugar. Every function preceded with the <code>async</code> keyword will be translated into a function that returns a <code>Future</code> containing the processing logic of the original function.</p>
<p>Let's picture it with a very lightweight example. Assume we will have a function that should return a number, but should be able to be processed asynchronously. With the keyword mentioned we could write this code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018">async fn give_number() -&gt; u32 {
    100
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>With the <code>async</code> hint the compiler will de-sugar the function into one that returns a <code>Future</code> like demonstrated by the following code.</p>
<pre><code class="language-rust ignore">fn give_number() -&gt; impl Future&lt;Output = u32&gt; {
    GiveNumberFuture
}

struct GiveNumberFuture {}

impl Future for GiveNumberFuture {
    // the return type of the original async function
    type Output = u32;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        // the expression returning the value of the async function wrapped
        // into the Poll::Ready state
        Poll::Ready(100)
    }
}
</code></pre>
<blockquote>
<p><img src="./images/note.png" alt="Note" /> The given example of desuggering the <code>async</code> function is used for demonstration purposes only and might not match the actual code generated by the compiler.</p>
</blockquote>
<h1><a class="header" href="#await" id="await">Await</a></h1>
<p>The term <code>await</code> is another keyword in the Rust programming language. This is used to tell the compiler that the current sequential processing shall be paused until the value of an asynchronous processing is available. Once the value is availble the processing continues. Like <code>async</code> the <code>await</code> keyword is also syntactic sugar for the developer writing code to be run asynchronously. It is used on variables that hold a <code>Future</code> to hint the compiler to generate code that allows to <code>poll</code> the actual state of the <code>Future</code> and only continue in case the value is ready. As <em>waiting</em> for the actual result of a <code>Future</code> also requires the capability of asynchronous processing this keyword can only be used within an <code>async fn</code>.</p>
<p>Let's illustrate the usage:</p>
<pre><code class="language-rust ignore">async fn give_number() -&gt; u32 {
    100
}

async fn wait_for_number() {
    let number = give_number().await;
    println!(&quot;Number: {}&quot;, number);
}
</code></pre>
<p>So the <code>wait_for_number</code> function requires to be <code>async</code> as well to be able to contain <code>await</code> points. While the <code>await</code>-ing of the presence of the value pauses the execution of this actual code the curret <em>thread</em> ore <em>processor core</em> is free to pick up other things to do until the <em>executor</em> decides to re-visit this <code>await</code> point to check if progress can be made.</p>
<h1><a class="header" href="#lets-build-a-runtime" id="lets-build-a-runtime">Let's Build a Runtime</a></h1>
<p>While all the theory and definitions are great to have and ensure that we are on the same page with respect to the terminology we use, nothing beats practical examples to fully understand or learn something new.</p>
<p>So the purpose of the upcomming chapters is to implement a <em>runtime / executor</em> that enables the use of asynchronous programming in upcomming projects. So let's start defining the first pieces and implement the <em>executor</em> step-by-step.</p>
<p>The main building blocks will be the <em>Brain</em> and <em>Thoughts</em>.</p>
<h2><a class="header" href="#the-thought" id="the-thought">The Thought</a></h2>
<p>The <em>Thought</em> is an entity the <em>Brain</em> is able to process. It is kind of a wrapper that contains the thing that need to be thought on - the <code>Future</code>. This <code>Future</code> requires polling until it unveils it's result. As the <code>Future</code> contained in the <code>Thought</code> will be shared accross <em>threads</em> or <em>cores</em> in my Raspberry Pi it need to be stored on heap memory and pinned at it location to prevent it from moving around in memory.</p>
<pre><code class="language-rust no_run noplayground"><span class="boring">//! # A Thought
</span><span class="boring">//!
</span><span class="boring">//! A Thought is an entity that wraps a `Future` the *Brain* could *think* on.
</span><span class="boring">//!
</span><span class="boring">
</span><span class="boring">extern crate alloc;
</span><span class="boring">
</span><span class="boring">use core::{
</span><span class="boring">    future::Future,
</span><span class="boring">    pin::Pin,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use alloc::boxed::Box;
</span><span class="boring">
</span>pub struct Thought {
    /// This is the actual thing the brain should process as part of the Thought
    pub thinkable: Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + 'static&gt;&gt;,
}
<span class="boring">
</span></code></pre>
<p>You might be wondering, why the <code>Future</code> that is assigned to the <code>Thought</code> has a fixed <code>Output</code> type being the unit type <code>()</code>?!</p>
<p>The initial intuition might indicate that this is wrong! How could a <code>Future</code> with the unit return type ever yield an actual value our code might <code>await</code> at some point? And you are doing right questioning this and I also struggled at this point in the first place. So lets try to explain why this actually is correct!</p>
<p><strong>The Requirement:</strong> At some point the <em>Brain</em> is required to maintain a list of <code>Thought</code>s that require processing. As the <code>Future</code> beeing part of the <code>Thought</code> ultimately will be part of the list as well, it's associated type required to be fully specified to allow it to participate in the list.</p>
<p><strong>Why is this correct:</strong> In a typical sequential execution model the process flow starts by entering the <code>main</code> function and continues until it reaches the end of the main function which typically does not return any value (keep aside any error codes or the like for the time beeing). However, within the <code>main</code> function you are free to call functions that returns values, work with those values and do further processing. But finally the program does not yield a value at all. From this we can draw an intuition to the asyncronous world. The <code>Thought</code> (and it's <code>Future</code> is kind of the async representation of the synchronous <em>main</em> function. Within the <code>Thought</code>'s <code>Future</code> we can embed other <code>Future</code>s that yields values, wait on them, process those values etc. But ultimately at the end the <code>Thought</code> itself does not return anything. However, the advantage of the <code>Thought</code>'s in async programming model is, that we can <em>throw</em> as many of them as we like onto the <em>Brain</em>. And the <em>Brain</em> can <em>decide</em> which <code>Thought</code> to process next and which need to be <em>parked</em> as it still waits for a value inside it's processing to be available. <em>Throwing</em> new <code>Thought</code>'s onto the <em>Brain</em>is also called <em>spawning</em>.</p>
<p>So the conslusion is: It's totally fine and absolutely correct that the <code>Thought</code> stores a <code>Future</code> that does not yield any result.</p>
<blockquote>
<p><img src="./images/note.png" alt="Note" /> If a <code>Future</code> <em>embedding</em> another <code>Future</code> and awaiting it's result before processing can continue it is also called <em>chaining</em> of <code>Future</code>'s. <em>Chaining</em> of <code>Future</code>'s in the async world is compareable to function calls in the syncronous world, where a function can only continue if the called function returns. The <em>chaining</em> of <code>Future</code>'s is unlikely to be implemented <em>manually</em> as this is done by the compiler when de-sugaring the <code>await</code> points within an <code>async</code> function.</p>
</blockquote>
<p>With the <code>Thought</code> defined let's try to implement ur first version of a <em>Brain</em> in the next chapter.</p>
<h2><a class="header" href="#the-first-naive-brain" id="the-first-naive-brain">The First Naive Brain</a></h2>
<p>With the first building blocks in place we might be able to sketch our first version of a <em>Brain</em>.</p>
<p>The first part we need to define is the struct that will contain the list of <code>Thoughts</code> that are about to be processed. We wrap them into an <code>Option</code> to distinguesh the items that require processing from the ones that are already finished - so no need to further <em>think</em> on them ...</p>
<pre><code class="language-rust ignore noplayground">struct Brain {
    /// the list of `Thoughts`s that require processing
    thoughts: Vec&lt;Option&lt;Thought&gt;&gt;,
}
</code></pre>
<p>Now we can implement a function that is able to take a <code>Future</code>, wrap it into a <code>Thought</code> and push it to the list.</p>
<pre><code class="language-rust ignore noplayground">impl Brain {
    /// Add a new `Future` to the [Brain], so it can be processed
    fn think_on(&amp;mut self, thinkable: impl Future&lt;Output = ()&gt; + 'static) {
        // ensure the given Future is getting a fixed position on the HEAP
        let thinkable = Box::pin(thinkable);
        // create the Thought
        let thought = Thought {
            thinkable,
        };
        // push the Thought to the list of thoughts to think on
        self.thoughts.push(Some(thought));
    }
}
</code></pre>
<p>Finally the <em>Brain</em> requires a function that allows processing of the list of <code>Thought</code>'s. This function will iterate over the items of <code>Brain::thoughts</code> and will call the <code>poll</code> function of the <code>Future</code> contain in the respective <code>Thought</code>. If this polling yields a <code>Poll::Pending</code> state the <code>Thought</code> will be kept in place of the list and is polled again at the next <em>cycle</em>.</p>
<pre><code class="language-rust ignore noplayground codenotcompile">impl Brain {
    /// Do the actual thinking - check for Thoughts that are waiting to be 
    /// processed and drive them to completion
    fn do_thinking(&amp;mut self) {
        // run through the list of Thoughts that require thinking
        for maybe_thought in self.thoughts.iter_mut() {
            if let Some(thought) = maybe_thought.take() {
                // polling the Future requires some kind of Context, we will
                // discuss this in the next chapter
                if let Poll::Pending = thought.thinkable.as_mut().poll(cx) {
                    // as long as the state is Poll::Pending we put the
                    // the Thought back in place for the next round
                    *maybe_thought = Some(thought);
                }
            }
        }
    }
}
</code></pre>
<p>The actual first sketch of the <code>Brain</code> has several flaws. One of them, for example, is that the <code>poll</code> function of the <code>Future</code> requires a <code>Context</code> to be passed. Without having this in place the code will actually not compile.</p>
<p>However, before dealing with the different challenges of the above coude let's have a look how we would actually use the <code>Brain</code>.</p>
<p>As a first step we will define a <code>Future</code> that returns a constant value after it has been polled for a fixed number of tries. Nothing really asynchronous here, you are totally right, but let's start simple.</p>
<pre><code class="language-rust ignore noplayground">struct GiveNumberFuture {
    give_after_tries: u32,
    current_tries: u32,
}

impl Future for GiveNumberFuture {
    type Output = u32;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let this = self.get_mut();
        println!(&quot;polled {} time(s)&quot;, this.current_tries + 1);
        if this.give_after_tries &gt; this.current_tries + 1 {
            this.current_tries += 1;
            Poll::Pending
        } else {
            Poll::Ready(20)
        }
    }
}
</code></pre>
<p>This <code>Future</code> does indeed return a value. So we need to embed it into a <code>Future</code> that does not return any value and can be <em>spawned</em> to the <code>Brain</code>. The most simple way to do so would be the creation of an <code>async</code> function that does not return any value and <code>await</code> the result of the <code>GiveNumberFuture</code> in it like so:</p>
<pre><code class="language-rust ignore noplayground">async fn main_thought() {
    let future = GiveNumberFuture {
        give_after_tries: 10,
        current_tries: 0,
    };

    let number = future.await;
    println!(&quot;waited for {}&quot;, number);
}
</code></pre>
<p>Within the <code>main</code> function we can now create our <code>Brain</code>, tell it to think on the <em>main thought</em> which will ultimately wait for the <code>GiveNumberValue</code> to yield it's result.</p>
<pre><code class="language-rust ignore noplayground codenotcompile">fn main() {
    println!(&quot;Hello, world!&quot;);

    let mut brain = Brain {
        thoughts: Vec::new(),
    };

    brain.think_on(main_thought());

    loop {
        brain.do_thinking();
    }
}
</code></pre>
<p>Assuming the first sketch of our <code>Brain</code> would already compile and run it would create the following output:</p>
<pre><code class="language-text">Hello, world!
polled 1 time(s)
polled 2 time(s)
polled 3 time(s)
polled 4 time(s)
polled 5 time(s)
polled 6 time(s)
polled 7 time(s)
polled 8 time(s)
polled 9 time(s)
polled 10 time(s)
waited for 20
</code></pre>
<h3><a class="header" href="#the-issues-of-the-naive-brain" id="the-issues-of-the-naive-brain">The Issues of the Naive Brain</a></h3>
<ol>
<li>The missing <code>Context</code> hindering it to compile - and what is it used for by the way?</li>
<li>The usage of a <code>Vec</code> to store the <code>Thought</code>'s may grow endlessly without further handling.</li>
<li>The <code>Brain</code> requires mutable access to allow adding of new <code>Thought</code>'s and processing them.</li>
</ol>
<p>Let's tackle them one by one in the next chapters.</p>
<h2><a class="header" href="#the-context-and-the-waker" id="the-context-and-the-waker">The Context and the Waker</a></h2>
<p>The first issue of our <a href="./03-02-first-brain.html">naive Brain</a> is, that it does not compile for an obvious reason: The signature of the <code>poll</code> function requires to pass a <code>Context</code> and we where not able to provide one for now, but - what is this <code>Context</code> about ?</p>
<h3><a class="header" href="#the-context" id="the-context">The Context</a></h3>
<p>In the current version of Rust, the <code>Context</code> that will be handed over to the <code>Future</code> while polling the same only contains a reference to a <code>Waker</code>. This <code>Waker</code> can be used to <em>wake</em> the processing of a <code>Future</code> at a later point in time, when the result of ths <code>Future</code> is likely to be present.</p>
<p>Our initial implementation of the <code>Brain</code> in the last chapter took a <code>Future</code> that returned a constant value after it has been polled 10 times. Everytime this polling returned <code>Poll::Pending</code> the <code>Brain</code> ensured that the next <em>processing cycle</em> will again invoke the <code>poll</code> function of this <code>Future</code>. This is quite inefficient as the contineusly polling of the <code>Future</code> will likely waste resources and processing capabilities of the <code>Brain</code>. In a real world scenario it will more likely be an event - a timer, an I/O event, an extern GPIO interrupt - that will indicate that the requested result of a <code>Future</code> is available.</p>
<p>But how could the <code>Brain</code> know, that the event for a specific <code>Future</code> has been raised and therefore the wrapping <code>Thought</code> need re-processing? This is, where the <code>Context</code> and it's containing <code>Waker</code> comes into play. The <code>Brain</code> will create a <code>Waker</code> for each <code>Thought</code> that is about to be processed and pass this as part of the <code>Context</code> to the <code>Future</code> that is polled. It is now the responsibility of the <code>Future</code> to store this <code>Waker</code> and use it to signal to the <code>Brain</code> that it need to re-process the current <code>Thought</code> this <code>Future</code> is wrapped into. The most common use-case is to register this <code>Waker</code> with a system I/O event handler or an interrupt handler. So if processing the <code>Thought</code> returns <code>Poll::Pending</code> the <code>Brain</code> can <em>park</em> this one until it got <em>woken</em> by the <code>Waker</code>.</p>
<blockquote>
<p><img src="./images/note.png" alt="Note" /> It's also possible that multiple <code>Thought</code>'s might share the same <code>Waker</code> if their re-processing is likely to depend on the same event, but for the sake of simplicity we stick to the creation of individual <code>Waker</code> for each <code>Thought</code> the <code>Brain</code> will process.</p>
</blockquote>
<h3><a class="header" href="#the-waker" id="the-waker">The Waker</a></h3>
<p>The high level concept of a <em>Waker</em> is kind of straight forward. A <em>Waker</em> defines the behavior of a thing (in our case the <code>Thought</code>) that provides the methods to get woken. This behavior is defined with the <code>Wakeable</code> trait. The high-level intuiton of a <code>Waker</code> will look like this:</p>
<pre><code class="language-rust ignore">type Waker = Arc&lt;dyn Wakeable&gt;;

pub trait Wakeable {
    /// Wake a Wakeable and consuming the [Arc]
    fn wake(self: Arc&lt;Self&gt;) {
        Self::wake_by_ref(&amp;self)
    }

    /// Wake the Wakeable keeping the Arc ref count intact
    fn wake_by_ref(self: &amp;'_ Arc&lt;Self&gt;);
}
</code></pre>
<br>
<details>
<summary>There are several challenges that need to be solved for a <code class="hljs">Waker</code> to allow its usage in a general way, as the fact that it is <i>tied</i> to a <code class="hljs">Thought</code> is kind of arbitrary from the <code class="hljs">Waker</code>'s point of view. So if you are curious about the low-level details feel free to continue reading by expanding this block.</summary>
<br>
<p>When <code>poll</code>ing a generic <code>Future</code> we've already seen, that the <code>Waker</code> will be passed as part of the <code>Context</code>. In the same way the <code>Future</code> as part of the <code>Thought</code> can't contain any generic <em>output type</em> because we would like to store it in some sort of a list in the <em>brain</em> - the <code>Waker</code> can't hold any generic type information either.</p>
<p>The solution to this problem is to use trsit objects like <code>Arc&lt;dyn Wakeable&gt;</code>. But as this still covers the type information we would need the <em>raw</em> version of the trait object to be stored. How can this be achieved? Well, the answer to this lies in the definition of a trait object. On raw/memory level its nothing more than a pointer to the actual data of the trait object together with a <a href="https://en.wikipedia.org/wiki/Virtual_method_table">V(irtual Function)Table</a>. The VTable as such is a list of function pointers where the very first parameter passed is the pointer to the actual data of the object this function belongs to. This type erased representation of a <code>Waker</code> is provided within the rust core library as <a href="https://doc.rust-lang.org/core/task/struct.RawWaker.html">RawWaker</a>.</p>
<p>For reference the definitions from the core library below:</p>
<pre><code class="language-rust ignore">pub struct RawWaker {
    data: *const (),
    vtable: &amp;'static RawWakerVTable,
}

pub struct RawWakerVTable {
    clone: unsafe fn(*const ()) -&gt; RawWaker,
    wake: unsafe fn(*const ()),
    wake_by_ref: unsafe fn(*const ()),
    drop: unsafe fn(*const ()),
}
</code></pre>
<h3><a class="header" href="#being-wakeable" id="being-wakeable">Being Wakeable</a></h3>
<p>So the first thing to get the <code>Thought</code> being wakeable is to create the functions that will make up the VTable for it. All those functions has one thing in common: They get the pointer to the current <code>Wakeable</code> as a type erased raw pointer. This need to be cast back into a typed raw pointer and from there to its <code>Arc</code> representation. This is actually safe as the only way this raw pointer could have been created is from the corresponding <code>Arc::into_raw</code> as shown later.</p>
<h4><a class="header" href="#function-to-clone" id="function-to-clone">Function to Clone</a></h4>
<p>The first function required will clone the <code>RawWaker</code> from the <code>Wakeable</code>. Being able to create clones of the <code>Waker</code> enables them to be stored as part of interrupt handler or I/O event handlers to allow waking the <code>Thought</code>'s from within them.</p>
<pre><code class="language-rust ignore">unsafe fn clone&lt;T: Wakeable&gt;(wakeable: *const ()) -&gt; RawWaker {
    let wakeable: *const T = wakeable.cast();
    let wakeable_ref: &amp;Arc&lt;T&gt; = &amp;*ManuallyDrop::new(
        Arc::from_raw(wakeable)
    );

    Arc::clone(wakeable_ref).into_raw_waker()
}
</code></pre>
<h4><a class="header" href="#function-to-wake" id="function-to-wake">Function to Wake</a></h4>
<p>The second function required will call the <code>wake</code> function of the <code>Wakeable</code> trait that actually will be implemented in the <code>Thought</code>. This function will consume the <code>Waker</code> (it's <code>Arc</code>) when called. This is most likely being called on cloned <code>Waker</code> for example inside an interrupt handler.</p>
<pre><code class="language-rust ignore">unsafe fn wake&lt;T: Wakeable&gt;(wakeable: *const ()) {
    // transfer the raw pointer back into it's type pointer
    let wakeable: *const T = wakeable.cast();
    let wakeable: Arc&lt;T&gt; = Arc::from_raw(wakeable);
    // wake the wakeable
    Wakeable::wake(wakeable);
}
</code></pre>
<p>There is also a non-consuming version of the <code>wake</code> function that should be used when the current <code>Wakeable</code> should not be consumed (as it is the only existing reference for example - like the one directly stored within the context)</p>
<pre><code class="language-rust ignore">unsafe fn wake_by_ref&lt;T: Wakeable&gt;(wakeable: *const ()) {
    // transfer the raw pointer back into it's type pointer
    let wakeable: *const T = wakeable.cast();
    let wakeable_ref = &amp;*ManuallyDrop::new(Arc::from_raw(wakeable));
    Wakeable::wake_by_ref(wakeable_ref);
}
</code></pre>
<h4><a class="header" href="#function-to-drop" id="function-to-drop">Function to Drop</a></h4>
<p>When handing out clones of the <code>Wakeable</code> it was necessary to ensure those will be dropped manually (by using <code>ManuallyDrop</code>). For this very reason we also require to implement the drop function for those clones. So just safely drop the <code>Arc</code> we build from the raw pointer.</p>
<pre><code class="language-rust ignore">unsafe fn drop&lt;T: Wakeable&gt;(wakeable: *const ()) {
    // transfer the raw pointer back into it's type pointer
    let wakeable: *const T = wakeable.cast();
    core::mem::drop(Arc::from_raw(wakeable));
}
</code></pre>
<p>With the functions in place building up the VTable its now possible to create a <code>RawWaker</code> that is a type erased version of a trait object representing the <code>Wakeable</code>.</p>
<pre><code class="language-rust ignore">fn into_raw_waker(self: Arc&lt;Self&gt;) -&gt; RawWaker {
    let raw_wakeable: *const () = Arc::into_raw(self).cast();
    let raw_wakeabe_vtable = &amp;Self::WAKER_VTABLE;

    RawWaker::new(
        raw_wakeable,
        raw_wakeabe_vtable,
    )
}
</code></pre>
<p>This function will be the only way to construct the <code>RawWaker</code> from a <code>Wakeable</code>. So it uses the <code>Arc::into_raw</code> to convert the <code>Arc</code> into a raw pointer which makes it totally safe to convert the raw pointers passed to the VTable functions back into an <code>Arc</code> using the <code>Arc::from_raw</code> function. To keep things tied to gether that belongs together we define a private trait the covers the VTable as well as the <code>into_raw_waker</code> function. In the following listing the details of the VTable functions are omitted for brevity.</p>
<pre><code class="language-rust ignored">trait WakeableTraitObject: Wakeable + Sized {
    /// build the RawWaker from the Wakeable consuming the [Arc] of it
    fn into_raw_waker(self: Arc&lt;Self&gt;) -&gt; RawWaker {
        let raw_wakeable: *const () = Arc::into_raw(self).cast();
        let raw_wakeabe_vtable = &amp;Self::WAKER_VTABLE;

        RawWaker::new(
            raw_wakeable,
            raw_wakeabe_vtable,
        )
    }

    /// specifiying the VTable for this Wakeable
    const WAKER_VTABLE: RawWakerVTable = RawWakerVTable::new(
        {
            unsafe fn clone&lt;T: Wakeable&gt;(wakeable: *const ()) -&gt; RawWaker {
                /* details omitted */
            }
            clone::&lt;Self&gt;
        },
        {
            unsafe fn wake&lt;T: Wakeable&gt;(wakeable: *const ()) {
                /* details omitted */
            }
            wake::&lt;Self&gt;
        },
        {
            unsafe fn wake_by_ref&lt;T: Wakeable&gt;(wakeable: *const ()) {
                /* details omitted */
            }
            wake_by_ref::&lt;Self&gt;
        },
        {
            unsafe fn drop&lt;T: Wakeable&gt;(wakeable: *const ()) {
                /* details omitted */
            }
            drop::&lt;Self&gt;
        }
    );
}
</code></pre>
<p>Finally we provide an auto trait implementation for all types that implement the <code>Wakeable</code> trait to also implement the <code>WakeableTraitObject</code> trait.</p>
<pre><code class="language-rust ignore">impl&lt;T: Wakeable&gt; WakeableTraitObject for T {}
</code></pre>
<p>With this in place we can now provide a function as part of the <code>Wakeable</code> trait that allows direct conversion from a <code>Wakeable</code> into a <code>Waker</code>.</p>
<pre><code class="language-rust ignore">pub trait Wakeable: Sized {
    fn wake(self: Arc&lt;Self&gt;) {
        Self::wake_by_ref(&amp;self)
    }

    fn wake_by_ref(self: &amp;'_ Arc&lt;Self&gt;);

    fn into_waker(self: &amp;Arc&lt;Self&gt;) -&gt; Waker {
        unsafe {
            Waker::from_raw(
                Self::into_raw_waker(Arc::clone(self))
            )
        }
    }
}
</code></pre>
</details>
<h3><a class="header" href="#waking-the-wakeable" id="waking-the-wakeable">Waking the Wakeable</a></h3>
<p>With the <code>Wakeable</code> trait we can now define our <code>Thought</code> to be able to get woken, right?</p>
<pre><code class="language-rust ignore noplayground">impl Wakeable for Thought {
    fn wake_by_ref(self: &amp;Arc&lt;Self&gt;) {
        // this Thought shall be able to get woken. This would require the Brain
        // to re-process the same. How to achive this? How to push to the Brain?
        // Should we pass a borrow of the Thoughtlist of the Brain to the
        // Thought?
    }
}
</code></pre>
<p>Even though we made the <code>Thought</code> wakeable and we could implement the waking functionality we are struggling here at the next issue with our initial <a href="./03-02-first-brain.html">naive Brain implementation</a></p>
<p>The reason is, that we store the <code>Thought</code>'s that require processing in a <code>Vec</code> within the <code>Brain</code>. To add entries to this list we would require mutual exclusive access to the same and we would require to share the access accross different <code>Thought</code>s. One possible way to address this is to use an <code>Arc</code> and a <em>Mutex-Like-Lock</em> around this <code>Vec</code>. But this will also not really solve the problem as the <code>Brain</code> always acquires this lock while processing the list of <code>Thought</code>'s. Therefore it is very unlikely that the <code>Waker</code> will ever get a chance to acquire the lock for adding it's related <code>Thought</code> back to the things the <code>Brain</code> need to process. Kind of a dilemma, right?</p>
<p>But - there is a solution to this. If we carefully check what the requirements of the list of the <code>Thought</code>'s within the <code>Brain</code> are we see that it is more acting like a <em>queue</em>. The <code>Brain</code> is picking up the things that need processing from the front of the queue and the <code>Wakeable</code> will push itself to the end of the queue once woken.</p>
<p>So what we will need is the implementation of a <strong>queue</strong>!</p>
<p>The queue does have 2 sides, one that allows <em>popping</em> of <code>Thought</code>s and one that allows <em>pushing</em> of <code>Thought</code>'s. And both ends shall be able to be shared independendtly - for example to the <code>Thought</code>'s that requires to push themself to the queue again once they are woken. The perfect candidate here is a <em>channel</em>. There are several kinds and implementations of channels available in the open source community. Based on our specific use case, where we might run the <code>Brain</code> on bare metal in <code>no_std</code> environment likely on different cores and the need to push <code>Thought</code>'s to this channel from different <code>Waker</code>, we require a <strong>Multi Producer Multi Consumer</strong> channel, that preferrably is implemented in a lock-free fashion.</p>
<p>Check out the next chapter for the details.</p>
<h2><a class="header" href="#multi-producer-multi-consumer-mpmc-channel" id="multi-producer-multi-consumer-mpmc-channel">Multi Producer Multi Consumer (MPMC) Channel</a></h2>
<p>The MPMC channel allows adding new entries from any core or thread (multi producer), picking the next entry by any core or thread (multi consumer) and works like a FIFO queue. There are for sure multiple approaches possible to implement such a channel in a non-blocking way. I will present quite a simple one here that has proven to work at least for all my current use cases in a bare metal <code>no_std</code> environment. The source code can be found <a href="https://github.com/RusPiRo/ruspiro-channel">here</a>.</p>
<h3><a class="header" href="#revisit-the-brain" id="revisit-the-brain">Revisit the Brain</a></h3>
<p>With the <em>channel</em> in place we can adopt the <code>Brain</code> to keep the <code>Sender</code> and the <code>Receiver</code> side of it. The <code>Sender</code> will be shared with the <code>Waker</code> while the <code>Receiver</code> is used by the <code>Brain</code> only.</p>
<pre><code class="language-rust ignore noplayground">struct Brain {
    /// the sender side of the mpmc channel to pass the ``Thought``s that
    /// require processing
    sender: mpmc::Sender&lt;Arc&lt;Thought&gt;&gt;,
    /// the receiver side of the mpmc channel the ``Brain`` picks ``Thought``s
    /// from to process them
    receiver: mpmc::Receiver&lt;Arc&lt;Thought&gt;&gt;,
}
</code></pre>
<blockquote>
<p><img src="./images/note.png" alt="Note" /> Well you might wonder why there is a <em>Multi-Sender-Multi-Consumer</em> channel if the consuming part is used by the <code>Brain</code> only? The reason is, that we will use the <code>Brain</code> to run it's code on different cores and therefor indeed a <em>multi-consumer</em> is required.</p>
</blockquote>
<h3><a class="header" href="#revisit-the-wakeable" id="revisit-the-wakeable">Revisit the Wakeable</a></h3>
<p>In addition to updating the <code>Brain</code> storing now the two sides of the channel we also can now store the <code>Sender</code> of the channel with each <code>Thought</code> which allows the same to push itself back to the queue of things the <code>Brain</code> should process.</p>
<p>The updated <code>Thought</code> will look like this:</p>
<pre><code class="language-rust ignore noplayground">pub struct Thought {
    /// This is the actual thing the brain should process as part of the Thought
    pub thinkable: DataLock&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + 'static&gt;&gt;&gt;,
    /// The sender side of the queue of the `Brain` to push myself for
    /// re-processing
    pub sender: mpmc::Sender&lt;Arc&lt;Thought&gt;&gt;,
}
</code></pre>
<p>The implementation of the <code>Wakeable</code> trait to add the wake behavior to it can now finally be implemented:</p>
<pre><code class="language-rust ignore noplayground">impl Wakeable for Thought {
    fn wake_by_ref(self: &amp;Arc&lt;Self&gt;) {
        let clone = Arc::clone(self);

        self.sender.send(clone);
    }
}
</code></pre>
<p>The final bit now is to always pass the <code>Sender</code> to the <code>Thought</code> once the <code>Brain</code> is requested to think on one:</p>
<pre><code class="language-rust ignore noplayground">fn think_on(&amp;self, thinkable: impl Future&lt;Output = ()&gt; + 'static) {
    // ensure the given Future is getting a fixed position on the HEAP
    let thinkable = Box::pin(thinkable);
    // create the Thought
    let thought = Arc::new(
        Thought {
                thinkable: DataLock::new(thinkable),
                sender: self.sender.clone(),
            }
        );
    // push the Thought to the list of thoughts to think on
    self.sender.send(thought);
}
</code></pre>
<h2><a class="header" href="#the-simple-brain" id="the-simple-brain">The simple Brain</a></h2>
<p>Now we have everything in place to implement a first functional simple <code>Brain</code>.</p>
<pre><code class="language-rust ignore noplayground">/// A quite naive Brain that should process the `Future`s wrapped in a `Thought`
struct Brain {
    /// the sender side of the mpmc channel to pass the ``Thought``s that
    /// require processing
    sender: mpmc::Sender&lt;Arc&lt;Thought&gt;&gt;,
    /// the receiver side of the mpmc channel the ``Brain`` picks ``Thought``s
    /// from to process them
    receiver: mpmc::Receiver&lt;Arc&lt;Thought&gt;&gt;,
}

impl Brain {
    fn default() -&gt; Self {
        let (sender, receiver) = mpmc::channel();

        Self {
            sender,
            receiver,
        }
    }

    /// Add a new `Future` to the [Brain], so it can be processed
    fn think_on(&amp;self, thinkable: impl Future&lt;Output = ()&gt; + 'static) {
        // ensure the given Future is getting a fixed position on the HEAP
        let thinkable = Box::pin(thinkable);
        // create the Thought
        let thought = Arc::new(
            Thought {
                    thinkable: DataLock::new(thinkable),
                    sender: self.sender.clone(),
                }
            );
        // push the Thought to the list of thoughts to think on
        self.sender.send(thought);
    }
}

impl Brain {
    /// Do the actual thinking - check for Thoughts that waits for processing
    /// and drive them to completion
    fn do_thinking(&amp;self) {
        // check if there is a new Thought available in the channel
        while let Ok(thought) = self.receiver.recv() {
            // create the Waker from the current Thought
            let waker = Wakeable::into_waker(&amp;thought);
            // create the Context from the given Waker
            let mut context = Context::from_waker(&amp;waker);
            // lock the Future contained in the Thought and poll it
            let mut thinkable = thought.thinkable.lock();
            if let Poll::Pending = thinkable.as_mut().poll(&amp;mut context) {
                // if the state is Poll::Pending we just unlock the Future
                drop(thinkable);
                // in case it will be still valid and required to re-process this
                // Thought the Waker will resend it through the channel
            }
        }
    }
}
</code></pre>
<p>The usage of this simple brain is pretty much similar to the first attempt. We implement an example <code>Future</code> and a simple <code>async</code> function that can be <em>spawned</em> to the <code>Brain</code> and is <code>await</code>ing the example <code>Future</code>.</p>
<pre><code class="language-rust ignore noplayground">struct GiveNumberFuture {
    give_after_tries: u32,
    current_tries: u32,
}

impl Future for GiveNumberFuture {
    type Output = u32;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let this = self.get_mut();
        println!(&quot;polled {} time(s)&quot;, this.current_tries + 1);
        if this.give_after_tries &gt; this.current_tries + 1 {
            this.current_tries += 1;
            cx.waker().wake_by_ref();
            Poll::Pending
        } else {
            Poll::Ready(20)
        }
    }
}

async fn main_thought() {
    let future = GiveNumberFuture {
        give_after_tries: 10,
        current_tries: 0,
    };

    let number = future.await;
    println!(&quot;waited for {}&quot;, number);
}
</code></pre>
<p>And finally the actual <code>main</code> function utilizing the <code>Brain</code> to process the <code>Future</code>.</p>
<pre><code class="language-rust ignore noplayground"><span class="boring">//! # Naive Async Processing
</span><span class="boring">//!
</span><span class="boring">//! Implementing a simple *Brain*
</span><span class="boring">
</span><span class="boring">extern crate alloc;
</span><span class="boring">
</span><span class="boring">use core::{
</span><span class="boring">    future::Future,
</span><span class="boring">    task::{Poll, Context},
</span><span class="boring">    pin::Pin,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use alloc::{
</span><span class="boring">    boxed::Box,
</span><span class="boring">    sync::Arc,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">use ruspiro_channel::mpmc;
</span><span class="boring">use ruspiro_lock::DataLock;
</span><span class="boring">
</span><span class="boring">mod thought;
</span><span class="boring">use thought::*;
</span><span class="boring">
</span><span class="boring">mod wakeable;
</span><span class="boring">use wakeable::Wakeable;
</span><span class="boring">
</span><span class="boring">/// A quite naive Brain that should process the `Future`s wrapped in a `Thought`
</span><span class="boring">struct Brain {
</span><span class="boring">    /// the sender side of the mpmc channel to pass the ``Thought``s that
</span><span class="boring">    /// require processing
</span><span class="boring">    sender: mpmc::Sender&lt;Arc&lt;Thought&gt;&gt;,
</span><span class="boring">    /// the receiver side of the mpmc channel the ``Brain`` picks ``Thought``s
</span><span class="boring">    /// from to process them
</span><span class="boring">    receiver: mpmc::Receiver&lt;Arc&lt;Thought&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Brain {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        let (sender, receiver) = mpmc::channel();
</span><span class="boring">
</span><span class="boring">        Self {
</span><span class="boring">            sender,
</span><span class="boring">            receiver,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Add a new `Future` to the [Brain], so it can be processed
</span><span class="boring">    fn think_on(&amp;self, thinkable: impl Future&lt;Output = ()&gt; + 'static) {
</span><span class="boring">        // ensure the given Future is getting a fixed position on the HEAP
</span><span class="boring">        let thinkable = Box::pin(thinkable);
</span><span class="boring">        // create the Thought
</span><span class="boring">        let thought = Arc::new(
</span><span class="boring">            Thought {
</span><span class="boring">                    thinkable: DataLock::new(thinkable),
</span><span class="boring">                    sender: self.sender.clone(),
</span><span class="boring">                }
</span><span class="boring">            );
</span><span class="boring">        // push the Thought to the list of thoughts to think on
</span><span class="boring">        self.sender.send(thought);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Brain {
</span><span class="boring">    /// Do the actual thinking - check for Thoughts that waits for processing
</span><span class="boring">    /// and drive them to completion
</span><span class="boring">    fn do_thinking(&amp;self) {
</span><span class="boring">        // check if there is a new Thought available in the channel
</span><span class="boring">        while let Ok(thought) = self.receiver.recv() {
</span><span class="boring">            // create the Waker from the current Thought
</span><span class="boring">            let waker = Wakeable::into_waker(&amp;thought);
</span><span class="boring">            // create the Context from the given Waker
</span><span class="boring">            let mut context = Context::from_waker(&amp;waker);
</span><span class="boring">            // lock the Future contained in the Thought and poll it
</span><span class="boring">            let mut thinkable = thought.thinkable.lock();
</span><span class="boring">            if let Poll::Pending = thinkable.as_mut().poll(&amp;mut context) {
</span><span class="boring">                // if the state is Poll::Pending we just unlock the Future
</span><span class="boring">                drop(thinkable);
</span><span class="boring">                // in case it will be still valid and required to re-process this
</span><span class="boring">                // Thought the Waker will resend it through the channel
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct GiveNumberFuture {
</span><span class="boring">    give_after_tries: u32,
</span><span class="boring">    current_tries: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Future for GiveNumberFuture {
</span><span class="boring">    type Output = u32;
</span><span class="boring">    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
</span><span class="boring">        let this = self.get_mut();
</span><span class="boring">        println!(&quot;polled {} time(s)&quot;, this.current_tries + 1);
</span><span class="boring">        if this.give_after_tries &gt; this.current_tries + 1 {
</span><span class="boring">            this.current_tries += 1;
</span><span class="boring">            cx.waker().wake_by_ref();
</span><span class="boring">            Poll::Pending
</span><span class="boring">        } else {
</span><span class="boring">            Poll::Ready(20)
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn main_thought() {
</span><span class="boring">    let future = GiveNumberFuture {
</span><span class="boring">        give_after_tries: 10,
</span><span class="boring">        current_tries: 0,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let number = future.await;
</span><span class="boring">    println!(&quot;waited for {}&quot;, number);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;Hello, world!&quot;);

    let brain = Brain::default();

    brain.think_on(main_thought());

    loop {
        brain.do_thinking();
    }
}
</code></pre>
<p>Running this will yield the result</p>
<pre><code class="language-text">Hello, world!
polled 1 time(s)
polled 2 time(s)
polled 3 time(s)
polled 4 time(s)
polled 5 time(s)
polled 6 time(s)
polled 7 time(s)
polled 8 time(s)
polled 9 time(s)
polled 10 time(s)
waited for 20
</code></pre>
<h1><a class="header" href="#proof-the-runtime" id="proof-the-runtime">Proof the Runtime</a></h1>
<p>After we have implemented our own simple runtime / executor to support the async implementation paradigm it's time to proof that it is really working. As we might do this without requiring to deploy this part to any actual embedded hardware we can execute this test within a normal operating system environment.</p>
<p>To do so we use a small binary crate utilizing our <code>Brain</code> implementation. The presence of different cores can be simulated by running different threads.</p>
<p>So the <code>main</code> function in this validation will look like this:</p>
<pre><code class="language-rust noplayground">fn main() {
    println!(&quot;Hello, world!&quot;);

    let brain = Arc::new(
        brain::Brain::default()
    );

    // assume we have 4 cores on the target system -&gt; spawn 3 threads
    // the current thread is the 4th core though
    for _ in 0..3 {
        let cloned_brain = Arc::clone(&amp;brain);
        std::thread::spawn( move || {
            loop {
                cloned_brain.do_thinking();
            }
        });
    }

    // just spawn 4 async executions ...
    brain.think_on(main_thought(10, 10));
    brain.think_on(main_thought(20, 5));
    brain.think_on(main_thought(30, 6));
    brain.think_on(main_thought(40, 3));

    // use the current thread as the 4th core
    loop {
        brain.do_thinking();

        // we could also spawn new  [Thought]s here or from within an
        // async fn to keep the Brain busy ..
    }
}
</code></pre>
<p>To be able to <em>look behind the scenes</em> a bit we adjust the implementation of our <code>Future</code> that will hand out a number after a certain amount of <code>poll</code>'s to see which <em>core</em>/<em>thread</em> the current <code>poll</code> is executed.</p>
<pre><code class="language-rust noplayground">struct GiveNumberFuture {
    number_to_give: u32,
    give_after_tries: u32,
    current_tries: u32,
}

impl Future for GiveNumberFuture {
    type Output = u32;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let this = self.get_mut();
        println!(&quot;polled {} time(s) - now on {:?}&quot;,
            this.current_tries + 1,
            std::thread::current().id()
        );
        if this.give_after_tries &gt; this.current_tries + 1 {
            this.current_tries += 1;
            cx.waker().wake_by_ref();
            Poll::Pending
        } else {
            Poll::Ready(this.number_to_give)
        }
    }
}

async fn main_thought(number: u32, tries: u32) {
    let future = GiveNumberFuture {
        number_to_give: number,
        give_after_tries: tries,
        current_tries: 0,
    };

    let number = future.await;
    println!(&quot;waited for {}&quot;, number);
}
</code></pre>
<p>Running now this example will yield the follwoing output</p>
<pre><code class="language-text">Hello, world!
polled 1 time(s) - now on ThreadId(1)
polled 1 time(s) - now on ThreadId(1)
polled 2 time(s) - now on ThreadId(1)
polled 3 time(s) - now on ThreadId(1)
waited for 40
polled 1 time(s) - now on ThreadId(3)
polled 2 time(s) - now on ThreadId(1)
polled 3 time(s) - now on ThreadId(3)
polled 4 time(s) - now on ThreadId(1)
polled 5 time(s) - now on ThreadId(3)
polled 1 time(s) - now on ThreadId(2)
polled 2 time(s) - now on ThreadId(3)
polled 3 time(s) - now on ThreadId(2)
polled 4 time(s) - now on ThreadId(3)
polled 5 time(s) - now on ThreadId(2)
waited for 20
polled 6 time(s) - now on ThreadId(1)
waited for 30
polled 2 time(s) - now on ThreadId(4)
polled 3 time(s) - now on ThreadId(3)
polled 4 time(s) - now on ThreadId(2)
polled 5 time(s) - now on ThreadId(1)
polled 6 time(s) - now on ThreadId(3)
polled 7 time(s) - now on ThreadId(2)
polled 8 time(s) - now on ThreadId(1)
polled 9 time(s) - now on ThreadId(2)
polled 10 time(s) - now on ThreadId(3)
waited for 10
</code></pre>
<p>You can clearely see how the different <em>cores</em>/<em>threads</em> are picking up the work to drive a waiting <code>Future</code> to completion.</p>
<h1><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h1>
<p>Well I hope the mystery of <code>async</code>/<code>await</code> is now gone. If are now inspired to write your own <em>Executor</em> or <em>Runtime</em> just feel free to do so. With those basic concepts you also could extend the functionality of the <code>Brain</code> to support more advanced features also often required in async processing.</p>
<p><strong>Thanks for reading this small book - happy async coding ...</strong></p>
<h1><a class="header" href="#the-author" id="the-author">The Author</a></h1>
<p>André Borrmann (aka <a href="https://users.rust-lang.org/u/2ndtalestudio">2ndTaleStudio</a>).</p>
<p>I started learning Rust the programming language in 2019. I was implementing a C++ bare metal kernel / OS on my Raspberry Pi back then and ran often into some memory issues that where hard to track down due to the lack of proper debugging tools in the bare metal environment. A colleague of mine introduced Rust to me with its promises on concise code and memory safety, a clear ownership model and the compile time checks that make it hard to run into data races and memory issues. So I gave it a try and never regret it!</p>
<p>In my job I'm using several programming languages like ABAP, C/C++, Java, Javascript/Typescript and Scala - however, Rust is now my favorite though.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
