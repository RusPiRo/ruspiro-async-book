## Motivation

I'm - at the time of writing - working on a Raspberry Pi OS written as much as possible in Rust. Especially in the space of micro computer and embedded systems where GPIO's are used to access sensors and the like the OS or program often *idles* waiting for external events but also blocking any further processing while doing so. So the decision was made, that one of the main features of this OS will be, that it utilises the 4 cores of the provided processor of the Raspberry Pi as best as possbile and thus allows asynchronous and parallel processing (without writing a full threading stack). But writing a custom operating system does mean that one need to deal with some restrictions. One with the most impact on the usage of Rust as programming language is, that it is not possible to use the standard library. So everything need to be built with `#[no_std]` in mind.

While Rusts feature to support asynchronous processing is already available for a while as part of the standard library, it just recently got available in `no_std` environments thanks to the continues efforts of the Rust language group. Even though the whole *async/await* in Rust was quite a mystery to me I started to design and implement a runtime for my Raspberry Pi OS. This pretty much allowd me to understand all the different pieces - like `async fn()` and `future.await` thingies - that build the entire asynchronous features available for the developer with a concise syntax and also enabled me to know how everything fits together.

To share my experience and insights that lead to the *de-mystification* for me I've written this book to also help others to have this kind of *a-ha* ðŸ’¡ effect.
